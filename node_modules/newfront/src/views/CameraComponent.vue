<template>
  <div style="display: flex; flex-direction: column; align-items: center;">
    <div style="position: relative;">
      <video ref="video" autoplay muted playsinline></video>
      <canvas ref="canvas"></canvas>
    </div>

    <!-- 📸 사진 촬영 버튼 -->
    <button @click="capturePhoto">📸 사진 촬영</button>
  </div>
</template>

<script>
import { uploadPhoto } from "../api";

export default {
  name: 'CameraComponent',

  data() {
    return {
      neckAngle: null,
      shoulderAngle: null
    };
  },

  mounted() {
    const video = this.$refs.video;
    const canvas = this.$refs.canvas;
    const ctx = canvas.getContext('2d');

    let scriptsLoaded = 0;

    const checkAllScriptsLoaded = () => {
      scriptsLoaded++;
      if (scriptsLoaded < 3) return;

      const pose = new window.Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
      });

      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      pose.onResults((results) => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

        if (!results.poseLandmarks) return;
        const lm = results.poseLandmarks;

        const drawCircle = (pt, color) => {
          ctx.beginPath();
          ctx.arc(pt.x * canvas.width, pt.y * canvas.height, 5, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.fill();
        };

        const connect = (p1, p2, color = 'rgba(0, 0, 255, 0.3)', width = 4) => {
          ctx.beginPath();
          ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
          ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height);
          ctx.strokeStyle = color;
          ctx.lineWidth = width;
          ctx.stroke();
        };

        const leftShoulder = lm[11];
        const rightShoulder = lm[12];
        const leftEar = lm[7];
        const rightEar = lm[8];

        if (!leftShoulder || !rightShoulder || !leftEar || !rightEar) return;

        // 거북목 분석
        const neck = {
          x: (leftShoulder.x + rightShoulder.x) / 2,
          y: (leftShoulder.y + rightShoulder.y) / 2
        };

        const headCenter = {
          x: (leftEar.x + rightEar.x) / 2,
          y: (leftEar.y + rightEar.y) / 2
        };

        const dx = neck.x - headCenter.x;
        const dy = neck.y - headCenter.y;
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        const angleFromVertical = Math.abs(90 - Math.abs(angle));

        // ✅ 각도 저장
        this.neckAngle = angleFromVertical;

        ctx.font = '20px Arial';
        ctx.fillStyle = angleFromVertical > 20 ? 'red' : 'green';
        ctx.fillText(`거북목 각도: ${angleFromVertical.toFixed(1)}°`, 10, 30);
        ctx.fillText(
          angleFromVertical > 20 ? '⚠️ 거북목 의심됨' : '✅ 정상 자세',
          10,
          60
        );

        drawCircle(neck, 'yellow');
        drawCircle(headCenter, 'blue');
        connect(headCenter, neck, 'rgba(255, 165, 0, 0.5)');

        // 어깨 기울기 분석
        const dxS = rightShoulder.x - leftShoulder.x;
        const dyS = rightShoulder.y - leftShoulder.y;
        const shoulderXDist = Math.abs(dxS);

        if (shoulderXDist > 0.05) {
          const radian = Math.atan2(dyS, dxS);
          const degree = radian * (180 / Math.PI);
          const shoulderAngle = degree;

          // ✅ 어깨 각도 저장
          this.shoulderAngle = shoulderAngle;

          let direction = '';
          if (shoulderAngle > 10) {
            direction = '↙️ 왼쪽 어깨 ↑';
          } else if (shoulderAngle < -10) {
            direction = '↘️ 오른쪽 어깨 ↑';
          } else {
            direction = '✅ 어깨 수평';
          }

          ctx.fillStyle = Math.abs(shoulderAngle) > 10 ? 'red' : 'green';
          ctx.fillText(`어깨 기울기: ${Math.abs(shoulderAngle).toFixed(1)}° ${direction}`, 10, 90);

          const color = Math.abs(shoulderAngle) > 10 ? 'red' : 'gray';
          const width = Math.abs(shoulderAngle) > 10 ? 6 : 2;
          connect(leftShoulder, rightShoulder, color, width);

          ctx.font = '16px Arial';
          ctx.fillStyle = 'red';
          if (shoulderAngle > 10) {
            ctx.fillText('⬆', leftShoulder.x * canvas.width - 10, leftShoulder.y * canvas.height - 10);
            ctx.fillText('⬇', rightShoulder.x * canvas.width - 10, rightShoulder.y * canvas.height + 20);
          } else if (shoulderAngle < -10) {
            ctx.fillText('⬇', leftShoulder.x * canvas.width - 10, leftShoulder.y * canvas.height + 20);
            ctx.fillText('⬆', rightShoulder.x * canvas.width - 10, rightShoulder.y * canvas.height - 10);
          }

          drawCircle(leftShoulder, 'red');
          drawCircle(rightShoulder, 'red');
        } else {
          ctx.fillStyle = 'gray';
          ctx.fillText(`어깨 기울기: 측면이라 측정 생략`, 10, 90);
        }
      });

      const camera = new window.Camera(video, {
        onFrame: async () => {
          await pose.send({ image: video });
        },
        width: 640,
        height: 480
      });

      camera.start();
    };

    const scriptPose = document.createElement('script');
    const scriptDrawing = document.createElement('script');
    const scriptCamera = document.createElement('script');

    scriptPose.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js';
    scriptDrawing.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js';
    scriptCamera.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

    scriptPose.onload = checkAllScriptsLoaded;
    scriptDrawing.onload = checkAllScriptsLoaded;
    scriptCamera.onload = checkAllScriptsLoaded;

    document.head.appendChild(scriptPose);
    document.head.appendChild(scriptDrawing);
    document.head.appendChild(scriptCamera);
  },

  methods: {
    async capturePhoto() {
      const canvas = this.$refs.canvas;
      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg'));

      const formData = new FormData();
      formData.append("photo", blob, "captured.jpg");

      const user = JSON.parse(localStorage.getItem("user"));
      const userId = user?.user_id;

      if (!userId) {
        alert("❌ 사용자 정보가 없습니다. 로그인 정보를 확인해주세요.");
        return;
      }

      formData.append("user_id", String(userId));

      // ✅ 분석 각도도 함께 전송
      formData.append("neck_angle", this.neckAngle != null ? this.neckAngle.toFixed(2) : "");
      formData.append("shoulder_angle", this.shoulderAngle != null ? this.shoulderAngle.toFixed(2) : "");


      console.log("📤 formData 확인");
      for (let [key, value] of formData.entries()) {
        console.log(key, value);
      }

      try {
        const res = await uploadPhoto(formData);
        if (res.data.success) {
          this.$emit('photoUploaded');
          alert("📸 사진이 찍혔습니다!");
        } else {
          console.error("❌ 업로드 실패:", res.data.message);
        }
      } catch (err) {
        console.error("❌ 업로드 오류:", err);
      }
    }
  }
};
</script>

<style scoped>
video {
  display: none;
}
canvas {
  width: 640px;
  height: 480px;
  border: 1px solid #ccc;
}
body {
  margin: 0;
  padding: 0;
}
</style>
