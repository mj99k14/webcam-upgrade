<template>
  <div style="display: flex; flex-direction: column; align-items: center;">
    <div style="position: relative;">
      <video ref="video" autoplay muted playsinline></video>
      <canvas ref="canvas"></canvas>
    </div>

    <!-- ğŸ“¸ ì‚¬ì§„ ì´¬ì˜ ë²„íŠ¼ -->
    <button @click="capturePhoto">ğŸ“¸ ì‚¬ì§„ ì´¬ì˜</button>
  </div>
</template>

<script>
import { uploadPhoto } from "../api";

export default {
  name: 'CameraComponent',

  data() {
    return {
      neckAngle: null,
      shoulderAngle: null
    };
  },

  mounted() {
    const video = this.$refs.video;
    const canvas = this.$refs.canvas;
    const ctx = canvas.getContext('2d');

    let scriptsLoaded = 0;

    const checkAllScriptsLoaded = () => {
      scriptsLoaded++;
      if (scriptsLoaded < 3) return;

      const pose = new window.Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
      });

      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      pose.onResults((results) => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

        if (!results.poseLandmarks) return;
        const lm = results.poseLandmarks;

        const drawCircle = (pt, color) => {
          ctx.beginPath();
          ctx.arc(pt.x * canvas.width, pt.y * canvas.height, 5, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.fill();
        };

        const connect = (p1, p2, color = 'rgba(0, 0, 255, 0.3)', width = 4) => {
          ctx.beginPath();
          ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
          ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height);
          ctx.strokeStyle = color;
          ctx.lineWidth = width;
          ctx.stroke();
        };

        const leftShoulder = lm[11];
        const rightShoulder = lm[12];
        const leftEar = lm[7];
        const rightEar = lm[8];

        if (!leftShoulder || !rightShoulder || !leftEar || !rightEar) return;

        // ê±°ë¶ëª© ë¶„ì„
        const neck = {
          x: (leftShoulder.x + rightShoulder.x) / 2,
          y: (leftShoulder.y + rightShoulder.y) / 2
        };

        const headCenter = {
          x: (leftEar.x + rightEar.x) / 2,
          y: (leftEar.y + rightEar.y) / 2
        };

        const dx = neck.x - headCenter.x;
        const dy = neck.y - headCenter.y;
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        const angleFromVertical = Math.abs(90 - Math.abs(angle));

        // âœ… ê°ë„ ì €ì¥
        this.neckAngle = angleFromVertical;

        ctx.font = '20px Arial';
        ctx.fillStyle = angleFromVertical > 20 ? 'red' : 'green';
        ctx.fillText(`ê±°ë¶ëª© ê°ë„: ${angleFromVertical.toFixed(1)}Â°`, 10, 30);
        ctx.fillText(
          angleFromVertical > 20 ? 'âš ï¸ ê±°ë¶ëª© ì˜ì‹¬ë¨' : 'âœ… ì •ìƒ ìì„¸',
          10,
          60
        );

        drawCircle(neck, 'yellow');
        drawCircle(headCenter, 'blue');
        connect(headCenter, neck, 'rgba(255, 165, 0, 0.5)');

        // ì–´ê¹¨ ê¸°ìš¸ê¸° ë¶„ì„
        const dxS = rightShoulder.x - leftShoulder.x;
        const dyS = rightShoulder.y - leftShoulder.y;
        const shoulderXDist = Math.abs(dxS);

        if (shoulderXDist > 0.05) {
          const radian = Math.atan2(dyS, dxS);
          const degree = radian * (180 / Math.PI);
          const shoulderAngle = degree;

          // âœ… ì–´ê¹¨ ê°ë„ ì €ì¥
          this.shoulderAngle = shoulderAngle;

          let direction = '';
          if (shoulderAngle > 10) {
            direction = 'â†™ï¸ ì™¼ìª½ ì–´ê¹¨ â†‘';
          } else if (shoulderAngle < -10) {
            direction = 'â†˜ï¸ ì˜¤ë¥¸ìª½ ì–´ê¹¨ â†‘';
          } else {
            direction = 'âœ… ì–´ê¹¨ ìˆ˜í‰';
          }

          ctx.fillStyle = Math.abs(shoulderAngle) > 10 ? 'red' : 'green';
          ctx.fillText(`ì–´ê¹¨ ê¸°ìš¸ê¸°: ${Math.abs(shoulderAngle).toFixed(1)}Â° ${direction}`, 10, 90);

          const color = Math.abs(shoulderAngle) > 10 ? 'red' : 'gray';
          const width = Math.abs(shoulderAngle) > 10 ? 6 : 2;
          connect(leftShoulder, rightShoulder, color, width);

          ctx.font = '16px Arial';
          ctx.fillStyle = 'red';
          if (shoulderAngle > 10) {
            ctx.fillText('â¬†', leftShoulder.x * canvas.width - 10, leftShoulder.y * canvas.height - 10);
            ctx.fillText('â¬‡', rightShoulder.x * canvas.width - 10, rightShoulder.y * canvas.height + 20);
          } else if (shoulderAngle < -10) {
            ctx.fillText('â¬‡', leftShoulder.x * canvas.width - 10, leftShoulder.y * canvas.height + 20);
            ctx.fillText('â¬†', rightShoulder.x * canvas.width - 10, rightShoulder.y * canvas.height - 10);
          }

          drawCircle(leftShoulder, 'red');
          drawCircle(rightShoulder, 'red');
        } else {
          ctx.fillStyle = 'gray';
          ctx.fillText(`ì–´ê¹¨ ê¸°ìš¸ê¸°: ì¸¡ë©´ì´ë¼ ì¸¡ì • ìƒëµ`, 10, 90);
        }
      });

      const camera = new window.Camera(video, {
        onFrame: async () => {
          await pose.send({ image: video });
        },
        width: 640,
        height: 480
      });

      camera.start();
    };

    const scriptPose = document.createElement('script');
    const scriptDrawing = document.createElement('script');
    const scriptCamera = document.createElement('script');

    scriptPose.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js';
    scriptDrawing.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js';
    scriptCamera.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

    scriptPose.onload = checkAllScriptsLoaded;
    scriptDrawing.onload = checkAllScriptsLoaded;
    scriptCamera.onload = checkAllScriptsLoaded;

    document.head.appendChild(scriptPose);
    document.head.appendChild(scriptDrawing);
    document.head.appendChild(scriptCamera);
  },

  methods: {
    async capturePhoto() {
      const canvas = this.$refs.canvas;
      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg'));

      const formData = new FormData();
      formData.append("photo", blob, "captured.jpg");

      const user = JSON.parse(localStorage.getItem("user"));
      const userId = user?.user_id;

      if (!userId) {
        alert("âŒ ì‚¬ìš©ì ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¡œê·¸ì¸ ì •ë³´ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.");
        return;
      }

      formData.append("user_id", String(userId));

      // âœ… ë¶„ì„ ê°ë„ë„ í•¨ê»˜ ì „ì†¡
      formData.append("neck_angle", this.neckAngle != null ? this.neckAngle.toFixed(2) : "");
      formData.append("shoulder_angle", this.shoulderAngle != null ? this.shoulderAngle.toFixed(2) : "");


      console.log("ğŸ“¤ formData í™•ì¸");
      for (let [key, value] of formData.entries()) {
        console.log(key, value);
      }

      try {
        const res = await uploadPhoto(formData);
        if (res.data.success) {
          this.$emit('photoUploaded');
          alert("ğŸ“¸ ì‚¬ì§„ì´ ì°í˜”ìŠµë‹ˆë‹¤!");
        } else {
          console.error("âŒ ì—…ë¡œë“œ ì‹¤íŒ¨:", res.data.message);
        }
      } catch (err) {
        console.error("âŒ ì—…ë¡œë“œ ì˜¤ë¥˜:", err);
      }
    }
  }
};
</script>

<style scoped>
video {
  display: none;
}
canvas {
  width: 640px;
  height: 480px;
  border: 1px solid #ccc;
}
body {
  margin: 0;
  padding: 0;
}
</style>
